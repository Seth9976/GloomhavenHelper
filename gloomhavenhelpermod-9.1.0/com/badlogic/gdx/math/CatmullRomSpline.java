package com.badlogic.gdx.math;

public class CatmullRomSpline implements Path {
   public Vector[] controlPoints;
   public boolean continuous;
   public int spanCount;
   private Vector tmp;
   private Vector tmp2;
   private Vector tmp3;

   public static Vector calculate(Vector out, float t, Vector[] points, boolean continuous, Vector tmp) {
      int n = continuous ? points.length : points.length - 3;
      float u = t * n;
      int i = t >= 1.0F ? n - 1 : (int)u;
      u -= i;
      return calculate(out, i, u, points, continuous, tmp);
   }

   public static Vector calculate(Vector out, int i, float u, Vector[] points, boolean continuous, Vector tmp) {
      int n = points.length;
      float u2 = u * u;
      float u3 = u2 * u;
      out.set(points[i]).scl(1.5F * u3 - 2.5F * u2 + 1.0F);
      if (continuous || i > 0) {
         out.add(tmp.set(points[(n + i - 1) % n]).scl(-0.5F * u3 + u2 - 0.5F * u));
      }

      if (continuous || i < n - 1) {
         out.add(tmp.set(points[(i + 1) % n]).scl(-1.5F * u3 + 2.0F * u2 + 0.5F * u));
      }

      if (continuous || i < n - 2) {
         out.add(tmp.set(points[(i + 2) % n]).scl(0.5F * u3 - 0.5F * u2));
      }

      return out;
   }

   public static Vector derivative(Vector out, float t, Vector[] points, boolean continuous, Vector tmp) {
      int n = continuous ? points.length : points.length - 3;
      float u = t * n;
      int i = t >= 1.0F ? n - 1 : (int)u;
      u -= i;
      return derivative(out, i, u, points, continuous, tmp);
   }

   public static Vector derivative(Vector out, int i, float u, Vector[] points, boolean continuous, Vector tmp) {
      int n = points.length;
      float u2 = u * u;
      out.set(points[i]).scl(-u * 5.0F + u2 * 4.5F);
      if (continuous || i > 0) {
         out.add(tmp.set(points[(n + i - 1) % n]).scl(-0.5F + u * 2.0F - u2 * 1.5F));
      }

      if (continuous || i < n - 1) {
         out.add(tmp.set(points[(i + 1) % n]).scl(0.5F + u * 4.0F - u2 * 4.5F));
      }

      if (continuous || i < n - 2) {
         out.add(tmp.set(points[(i + 2) % n]).scl(-u + u2 * 1.5F));
      }

      return out;
   }

   public CatmullRomSpline() {
   }

   public CatmullRomSpline(Vector[] controlPoints, boolean continuous) {
      this.set(controlPoints, continuous);
   }

   public CatmullRomSpline set(Vector[] controlPoints, boolean continuous) {
      if (this.tmp == null) {
         this.tmp = controlPoints[0].cpy();
      }

      if (this.tmp2 == null) {
         this.tmp2 = controlPoints[0].cpy();
      }

      if (this.tmp3 == null) {
         this.tmp3 = controlPoints[0].cpy();
      }

      this.controlPoints = controlPoints;
      this.continuous = continuous;
      this.spanCount = continuous ? controlPoints.length : controlPoints.length - 3;
      return this;
   }

   public Vector valueAt(Vector out, float t) {
      int n = this.spanCount;
      float u = t * n;
      int i = t >= 1.0F ? n - 1 : (int)u;
      u -= i;
      return this.valueAt(out, i, u);
   }

   public Vector valueAt(Vector out, int span, float u) {
      return calculate(out, this.continuous ? span : span + 1, u, this.controlPoints, this.continuous, this.tmp);
   }

   public Vector derivativeAt(Vector out, float t) {
      int n = this.spanCount;
      float u = t * n;
      int i = t >= 1.0F ? n - 1 : (int)u;
      u -= i;
      return this.derivativeAt(out, i, u);
   }

   public Vector derivativeAt(Vector out, int span, float u) {
      return derivative(out, this.continuous ? span : span + 1, u, this.controlPoints, this.continuous, this.tmp);
   }

   public int nearest(Vector in) {
      return this.nearest(in, 0, this.spanCount);
   }

   public int nearest(Vector in, int start, int count) {
      while (start < 0) {
         start += this.spanCount;
      }

      int result = start % this.spanCount;
      float dst = in.dst2(this.controlPoints[result]);

      for (int i = 1; i < count; i++) {
         int idx = (start + i) % this.spanCount;
         float d = in.dst2(this.controlPoints[idx]);
         if (d < dst) {
            dst = d;
            result = idx;
         }
      }

      return result;
   }

   public float approximate(Vector v) {
      return this.approximate(v, this.nearest(v));
   }

   public float approximate(Vector in, int start, int count) {
      return this.approximate(in, this.nearest(in, start, count));
   }

   public float approximate(Vector in, int near) {
      int n = near;
      Vector nearest = (T)this.controlPoints[near];
      Vector previous = (T)this.controlPoints[near > 0 ? near - 1 : this.spanCount - 1];
      Vector next = (T)this.controlPoints[(near + 1) % this.spanCount];
      float dstPrev2 = in.dst2(previous);
      float dstNext2 = in.dst2(next);
      Vector P1;
      Vector P2;
      Vector P3;
      if (dstNext2 < dstPrev2) {
         P1 = nearest;
         P2 = next;
         P3 = in;
      } else {
         P1 = previous;
         P2 = nearest;
         P3 = in;
         n = near > 0 ? near - 1 : this.spanCount - 1;
      }

      float L1Sqr = P1.dst2(P2);
      float L2Sqr = P3.dst2(P2);
      float L3Sqr = P3.dst2(P1);
      float L1 = (float)Math.sqrt(L1Sqr);
      float s = (L2Sqr + L1Sqr - L3Sqr) / (2.0F * L1);
      float u = MathUtils.clamp((L1 - s) / L1, 0.0F, 1.0F);
      return (n + u) / this.spanCount;
   }

   public float locate(Vector v) {
      return this.approximate(v);
   }

   @Override
   public float approxLength(int samples) {
      float tempLength = 0.0F;

      for (int i = 0; i < samples; i++) {
         this.tmp2.set(this.tmp3);
         this.valueAt(this.tmp3, i / (samples - 1.0F));
         if (i > 0) {
            tempLength += this.tmp2.dst(this.tmp3);
         }
      }

      return tempLength;
   }
}
