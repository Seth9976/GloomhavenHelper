package com.badlogic.gdx.backends.lwjgl3.audio;

import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.StreamUtils;
import java.io.EOFException;
import java.io.FilterInputStream;
import java.io.IOException;

public class Wav {
   public static class Music extends OpenALMusic {
      private Wav.WavInputStream input;

      public Music(OpenALLwjgl3Audio audio, FileHandle file) {
         super(audio, file);
         this.input = new Wav.WavInputStream(file);
         if (!audio.noDevice) {
            this.setup(this.input.channels, this.input.sampleRate);
         }
      }

      @Override
      public int read(byte[] buffer) {
         if (this.input == null) {
            this.input = new Wav.WavInputStream(this.file);
            this.setup(this.input.channels, this.input.sampleRate);
         }

         try {
            return this.input.read(buffer);
         } catch (IOException var3) {
            throw new GdxRuntimeException("Error reading WAV file: " + this.file, var3);
         }
      }

      @Override
      public void reset() {
         StreamUtils.closeQuietly(this.input);
         this.input = null;
      }
   }

   public static class Sound extends OpenALSound {
      public Sound(OpenALLwjgl3Audio audio, FileHandle file) {
         super(audio);
         if (!audio.noDevice) {
            Wav.WavInputStream input = null;

            try {
               input = new Wav.WavInputStream(file);
               this.setup(StreamUtils.copyStreamToByteArray(input, input.dataRemaining), input.channels, input.sampleRate);
            } catch (IOException var8) {
               throw new GdxRuntimeException("Error reading WAV file: " + file, var8);
            } finally {
               StreamUtils.closeQuietly(input);
            }
         }
      }
   }

   private static class WavInputStream extends FilterInputStream {
      int channels;
      int sampleRate;
      int dataRemaining;

      WavInputStream(FileHandle file) {
         super(file.read());

         try {
            if (this.read() == 82 && this.read() == 73 && this.read() == 70 && this.read() == 70) {
               this.skipFully(4);
               if (this.read() == 87 && this.read() == 65 && this.read() == 86 && this.read() == 69) {
                  int fmtChunkLength = this.seekToChunk('f', 'm', 't', ' ');
                  int type = this.read() & 0xFF | (this.read() & 0xFF) << 8;
                  if (type != 1) {
                     throw new GdxRuntimeException("WAV files must be PCM: " + type);
                  } else {
                     this.channels = this.read() & 0xFF | (this.read() & 0xFF) << 8;
                     if (this.channels != 1 && this.channels != 2) {
                        throw new GdxRuntimeException("WAV files must have 1 or 2 channels: " + this.channels);
                     } else {
                        this.sampleRate = this.read() & 0xFF | (this.read() & 0xFF) << 8 | (this.read() & 0xFF) << 16 | (this.read() & 0xFF) << 24;
                        this.skipFully(6);
                        int bitsPerSample = this.read() & 0xFF | (this.read() & 0xFF) << 8;
                        if (bitsPerSample != 16) {
                           throw new GdxRuntimeException("WAV files must have 16 bits per sample: " + bitsPerSample);
                        } else {
                           this.skipFully(fmtChunkLength - 16);
                           this.dataRemaining = this.seekToChunk('d', 'a', 't', 'a');
                        }
                     }
                  }
               } else {
                  throw new GdxRuntimeException("Invalid wave file header: " + file);
               }
            } else {
               throw new GdxRuntimeException("RIFF header not found: " + file);
            }
         } catch (Throwable var5) {
            StreamUtils.closeQuietly(this);
            throw new GdxRuntimeException("Error reading WAV file: " + file, var5);
         }
      }

      private int seekToChunk(char c1, char c2, char c3, char c4) throws IOException {
         while (true) {
            boolean found = this.read() == c1;
            found &= this.read() == c2;
            found &= this.read() == c3;
            found &= this.read() == c4;
            int chunkLength = this.read() & 0xFF | (this.read() & 0xFF) << 8 | (this.read() & 0xFF) << 16 | (this.read() & 0xFF) << 24;
            if (chunkLength == -1) {
               throw new IOException("Chunk not found: " + c1 + c2 + c3 + c4);
            }

            if (found) {
               return chunkLength;
            }

            this.skipFully(chunkLength);
         }
      }

      private void skipFully(int count) throws IOException {
         while (count > 0) {
            long skipped = this.in.skip(count);
            if (skipped <= 0L) {
               throw new EOFException("Unable to skip.");
            }

            count = (int)(count - skipped);
         }
      }

      @Override
      public int read(byte[] buffer) throws IOException {
         if (this.dataRemaining == 0) {
            return -1;
         } else {
            int offset = 0;

            do {
               int length = Math.min(super.read(buffer, offset, buffer.length - offset), this.dataRemaining);
               if (length == -1) {
                  return offset > 0 ? offset : -1;
               }

               offset += length;
               this.dataRemaining -= length;
            } while (offset < buffer.length);

            return offset;
         }
      }
   }
}
